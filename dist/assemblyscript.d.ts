// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../binaryen
//   ../wabt
//   ../long

declare module 'assemblyscript' {
  /**
    * The exported AssemblyScript namespace.
    *
    * <h4>Sub-namespaces</h4>
    * <ul style="margin: 0; padding: 0; list-style: none">
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/builtins|builtins}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/expressions|expressions}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/library|library}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/reflection|reflection}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/statements|statements}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/typescript|typescript}</li>
    *   <li class="tsd-kind-module"><span class="tsd-kind-icon" /> {@link assemblyscript/util|util}</li>
    * </ul>
    *
    * @module assemblyscript
    * @preferred
    */ /** */
  import * as builtins from "assemblyscript/builtins";
  import * as expressions from "assemblyscript/expressions";
  import * as library from "assemblyscript/library";
  import * as reflection from "assemblyscript/reflection";
  import * as typescript from "assemblyscript/typescript";
  import * as statements from "assemblyscript/statements";
  import * as util from "assemblyscript/util";
  import { Compiler, CompilerTarget } from "assemblyscript/compiler";
  import { Memory } from "assemblyscript/memory";
  import { Profiler } from "assemblyscript/profiler";
  /** AssemblyScript version. */
  export const version: string;
  export { builtins, Compiler, CompilerTarget, expressions, library, Memory, Profiler, reflection, statements, typescript, util };
}

declare module 'assemblyscript/builtins' {
  /**
    * Compiler components dealing with built-in functions.
    *
    * Functions exported by this module correspond to the respective built-in functions. Each takes
    * TypeScript AST-objects and compiles them to opcodes directly.
    *
    * @module assemblyscript/builtins
    */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Tests if the specified file is a library file. */
  export function isLibraryFile(file: ts.SourceFile): boolean;
  /** Tests if the specified file is a standard file. */
  export function isStandardFile(file: ts.SourceFile): boolean;
  /** Tests if the specified function name corresponds to a built-in function. */
  export function isBuiltinFunction(name: string, isGlobalName?: boolean): boolean;
  /** An array of the statically linked runtime function names. */
  export const runtimeNames: string[];
  /** Tests if the specified function name corresponds to a linked runtime function. */
  export function isRuntimeFunction(name: string, isGlobalName?: boolean): boolean;
  /** Global variable values. */
  export const globals: {
      [key: string]: number;
  };
  /** A pair of TypeScript expressions. */
  export interface TypeScriptExpressionPair {
      0: ts.Expression;
      1: ts.Expression;
  }
  /** A pair of Binaryen expressions. */
  export interface BinaryenExpressionPair {
      0: Expression;
      1: Expression;
  }
  /** Compiles a sign-agnostic rotate left operation. */
  export function rotl(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
  /** Compiles a sign-agnostic rotate right operation. */
  export function rotr(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
  /** Compiles a sign-agnostic count leading zero bits operation. */
  export function clz(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a sign-agnostic count tailing zero bits operation. */
  export function ctz(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a sign-agnostic count number of one bits operation. */
  export function popcnt(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles an absolute value operation. */
  export function abs(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a ceiling operation. */
  export function ceil(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a floor operation. */
  export function floor(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a square root operation. */
  export function sqrt(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a round to the nearest integer towards zero operation. */
  export function trunc(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a round to the nearest integer tied to even operation. */
  export function nearest(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a minimum of two floats operation. */
  export function min(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
  /** Compiles a maximum of two floats operation. */
  export function max(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
  /** Compiles a copysign operation that composes a float from the magnitude of `x` and the sign of `y`. */
  export function copysign(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
  /** Compiles a reinterpretation of a float as an int respectively of an int as a float. */
  export function reinterpret(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a current memory operation. */
  export function current_memory(compiler: Compiler): Expression;
  /** Compiles a grow memory operation. */
  export function grow_memory(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles an unreachable operation. */
  export function unreachable(compiler: Compiler): Expression;
  /** Compiles a load from memory operation. */
  export function load(compiler: Compiler, type: Type, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a store to memory operation. */
  export function store(compiler: Compiler, type: Type, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
  /** Compiles a sizeof operation determining the byte size of a type. */
  export function sizeof(compiler: Compiler, type: Type): Expression;
  /** Compiles an unsafe cast operation casting a value from one type to another. */
  export function unsafe_cast(expr: Expression): Expression;
  /** Compiles a check for NaN operation. */
  export function isNaN(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  /** Compiles a check for a finite number operation. */
  export function isFinite(compiler: Compiler, node: ts.Expression, expr: Expression): Expression;
  export function internal_fmod(compiler: Compiler, nodes: TypeScriptExpressionPair, exprs: BinaryenExpressionPair): Expression;
}

declare module 'assemblyscript/expressions' {
  /**
    * Compiler components dealing with TypeScript expressions.
    * @module assemblyscript/expressions
    * @preferred
    */ /** */
  export * from "assemblyscript/expressions/arrayliteral";
  export * from "assemblyscript/expressions/as";
  export * from "assemblyscript/expressions/binary";
  export * from "assemblyscript/expressions/call";
  export * from "assemblyscript/expressions/conditional";
  export * from "assemblyscript/expressions/elementaccess";
  export * from "assemblyscript/expressions/helpers/load";
  export * from "assemblyscript/expressions/helpers/loadorstore";
  export * from "assemblyscript/expressions/helpers/store";
  export * from "assemblyscript/expressions/identifier";
  export * from "assemblyscript/expressions/literal";
  export * from "assemblyscript/expressions/new";
  export * from "assemblyscript/expressions/omitted";
  export * from "assemblyscript/expressions/parenthesized";
  export * from "assemblyscript/expressions/postfixunary";
  export * from "assemblyscript/expressions/prefixunary";
  export * from "assemblyscript/expressions/propertyaccess";
  import * as binaryen from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as reflection from "assemblyscript/reflection";
  import * as ts from "assemblyscript/typescript";
  /** Compiles any supported expression. */
  export function compile(compiler: Compiler, node: ts.Expression, contextualType: reflection.Type): binaryen.Expression;
  /** Evaluates any supported expression. Returns `null` if that's not possible. */
  export function evaluate(node: ts.Expression, contextualType: reflection.Type): number | Long | string | Array<number | Long | string | null> | null;
}

declare module 'assemblyscript/library' {
  /** AssemblyScript version. */
  export const version: string;
  /** Library sources for in-browser usage. */
  export const files: {
    [key: string]: string;
  };
  /** Precompiled memory management runtime as a base64-encoded string. */
  export const runtime: string;
}

declare module 'assemblyscript/reflection' {
  /**
    * Reflection components representing the WebAssembly output.
    * @module assemblyscript/reflection
    * @preferred
    */ /** */
  export * from "assemblyscript/reflection/class";
  export * from "assemblyscript/reflection/enum";
  export * from "assemblyscript/reflection/function";
  export * from "assemblyscript/reflection/object";
  export * from "assemblyscript/reflection/property";
  export * from "assemblyscript/reflection/type";
  export * from "assemblyscript/reflection/variable";
}

declare module 'assemblyscript/typescript' {
  import * as ts from "assemblyscript/--/lib/typescript";
  export import ArrayLiteralExpression = ts.ArrayLiteralExpression;
  export import ArrayTypeNode = ts.ArrayTypeNode;
  export import AssertionExpression = ts.AssertionExpression;
  export import BinaryExpression = ts.BinaryExpression;
  export import Block = ts.Block;
  export import BreakStatement = ts.BreakStatement;
  export import CallExpression = ts.CallExpression;
  export import ClassDeclaration = ts.ClassDeclaration;
  import CompilerHost = ts.CompilerHost;
  export import ConditionalExpression = ts.ConditionalExpression;
  export import ConstructorDeclaration = ts.ConstructorDeclaration;
  export import ContinueStatement = ts.ContinueStatement;
  export import DiagnosticCategory = ts.DiagnosticCategory;
  export import DiagnosticCollection = ts.DiagnosticCollection;
  export import DiagnosticMessage = ts.DiagnosticMessage;
  export import Diagnostic = ts.Diagnostic;
  export import DoStatement = ts.DoStatement;
  export import ElementAccessExpression = ts.ElementAccessExpression;
  export import EnumDeclaration = ts.EnumDeclaration;
  export import EnumMember = ts.EnumMember;
  export import EntityName = ts.EntityName;
  export import ExpressionStatement = ts.ExpressionStatement;
  export import Expression = ts.Expression;
  import FormatDiagnosticsHost = ts.FormatDiagnosticsHost;
  export import ForStatement = ts.ForStatement;
  export import FunctionLikeDeclaration = ts.FunctionLikeDeclaration;
  export import FunctionDeclaration = ts.FunctionDeclaration;
  export import GetAccessorDeclaration = ts.GetAccessorDeclaration;
  export import Identifier = ts.Identifier;
  export import IfStatement = ts.IfStatement;
  export import LiteralExpression = ts.LiteralExpression;
  export import MethodDeclaration = ts.MethodDeclaration;
  export import ModifierFlags = ts.ModifierFlags;
  export import NewExpression = ts.NewExpression;
  export import NodeArray = ts.NodeArray;
  export import NodeFlags = ts.NodeFlags;
  export import Node = ts.Node;
  export import NumericLiteral = ts.NumericLiteral;
  export import OmittedExpression = ts.OmittedExpression;
  export import ParenthesizedExpression = ts.ParenthesizedExpression;
  export import PostfixUnaryExpression = ts.PostfixUnaryExpression;
  export import PrefixUnaryExpression = ts.PrefixUnaryExpression;
  export import Program = ts.Program;
  export import PropertyAccessExpression = ts.PropertyAccessExpression;
  export import PropertyDeclaration = ts.PropertyDeclaration;
  export import TypeAliasDeclaration = ts.TypeAliasDeclaration;
  export import TypeChecker = ts.TypeChecker;
  export import TypeNode = ts.TypeNode;
  export import TypeParameterDeclaration = ts.TypeParameterDeclaration;
  export import TypeReferenceNode = ts.TypeReferenceNode;
  export import TypeReference = ts.TypeReference;
  export import Type = ts.Type;
  export import VariableDeclarationList = ts.VariableDeclarationList;
  export import VariableStatement = ts.VariableStatement;
  export import ReturnStatement = ts.ReturnStatement;
  export import ScriptTarget = ts.ScriptTarget;
  export import SetAccessorDeclaration = ts.SetAccessorDeclaration;
  export import SourceFile = ts.SourceFile;
  export import Statement = ts.Statement;
  export import StringLiteral = ts.StringLiteral;
  export import SwitchStatement = ts.SwitchStatement;
  export import Symbol = ts.Symbol;
  export import SyntaxKind = ts.SyntaxKind;
  export import ThrowStatement = ts.ThrowStatement;
  export import UnionTypeNode = ts.UnionTypeNode;
  export import WhileStatement = ts.WhileStatement;
  export import getPreEmitDiagnostics = ts.getPreEmitDiagnostics;
  export import getSourceFileOfNode = ts.getSourceFileOfNode;
  export import getTextOfNode = ts.getTextOfNode;
  export import isDeclaration = ts.isDeclaration;
  export import createDiagnosticCollection = ts.createDiagnosticCollection;
  export import createDiagnosticForNode = ts.createDiagnosticForNode;
  export import createProgram = ts.createProgram;
  export import createSourceFile = ts.createSourceFile;
  export import createNodeArray = ts.createNodeArray;
  export { DiagnosticsEx } from "assemblyscript/typescript/diagnosticMessages.generated";
  /** Default format diagnostics host for convenience. */
  export const defaultFormatDiagnosticsHost: FormatDiagnosticsHost;
  /** Default compiler options for AssemblyScript compilation. */
  export const defaultCompilerOptions: ts.CompilerOptions;
  /** Creates an AssemblyScript-compatible compiler host. */
  export function createCompilerHost(moduleSearchLocations: string[], entryFileSource?: string, entryFileName?: string): CompilerHost;
  /** Formats a diagnostic message in plain text. */
  export function formatDiagnosticsEx(diagnostics: Diagnostic[], host?: FormatDiagnosticsHost): string;
  /** Formats a diagnostic message with terminal colors and source context. */
  export function formatDiagnosticsWithColorAndContextEx(diagnostics: Diagnostic[], host?: FormatDiagnosticsHost): string;
  /** Prints a diagnostic message to console. */
  export function printDiagnostic(diagnostic: Diagnostic): void;
  /** Gets the name of a symbol.  */
  export function getNameOfSymbol(symbol: Symbol): string;
}

declare module 'assemblyscript/statements' {
  /**
    * Compiler components dealing with TypeScript statements.
    * @module assemblyscript/statements
    */ /** */
  import { Statement } from "binaryen";
  import Compiler from "assemblyscript/compiler";
  import * as ts from "assemblyscript/typescript";
  /** Compiles any supported statement. */
  export function compile(compiler: Compiler, node: ts.Statement): Statement | null;
  /** Compiles a block statement. */
  export function compileBlock(compiler: Compiler, node: ts.Block): Statement | null;
  /** Compiles a break statement. */
  export function compileBreak(compiler: Compiler, node: ts.BreakStatement | ts.ContinueStatement): Statement;
  /** Compiles a do loop statement. */
  export function compileDo(compiler: Compiler, node: ts.DoStatement): Statement;
  /** Compiles an expression statement. */
  export function compileExpression(compiler: Compiler, node: ts.ExpressionStatement): Statement;
  /** Compiles a for loop statement. */
  export function compileFor(compiler: Compiler, node: ts.ForStatement): Statement;
  /** Compiles an if statement. */
  export function compileIf(compiler: Compiler, node: ts.IfStatement): Statement;
  /** Compiles a return statement. */
  export function compileReturn(compiler: Compiler, node: ts.ReturnStatement): Statement;
  /** Compiles a switch statement. */
  export function compileSwitch(compiler: Compiler, node: ts.SwitchStatement): Statement;
  /** Compiles a throw statement. */
  export function compileThrow(compiler: Compiler): Statement;
  /** Compiles a variable declaration statement. */
  export function compileVariable(compiler: Compiler, node: ts.VariableStatement): Statement | null;
  /** Compiles a while loop statement. */
  export function compileWhile(compiler: Compiler, node: ts.WhileStatement): Statement;
}

declare module 'assemblyscript/util' {
  /**
    * Utility functions.
    * @module assemblyscript/util
    */ /** */
  import * as ts from "assemblyscript/typescript";
  import * as wabt from "wabt";
  import { Type, Function, FunctionTemplate, Class, ClassTemplate } from "assemblyscript/reflection";
  /** Tests if the specified node, or optionally either its parent, has an 'export' modifier. */
  export function isExport(node: ts.Node, checkParent?: boolean): boolean;
  /** Tests if the specified node, or optionally either its parent, has a 'declare' modifier. */
  export function isDeclare(node: ts.Node, checkParent?: boolean): boolean;
  /** Tests if the specified node has a 'static' modifier or is otherwise part of a static context. */
  export function isStatic(node: ts.Node): boolean;
  /** Tests if the specified node has an 'abstract' modifier. */
  export function isAbstract(node: ts.Node): boolean;
  /** Tests if the specified node is flagged 'const'. */
  export function isConst(node: ts.Node): boolean;
  /** Gets the reflected type of an expression. */
  export function getReflectedType(node: ts.Expression): Type;
  /** Sets the reflected type of an expression. */
  export function setReflectedType(node: ts.Expression, type: Type): void;
  /** Gets the reflected function instance (describing a function with generic types resolved) of a function declaration. */
  export function getReflectedFunction(node: ts.FunctionLikeDeclaration): Function;
  /** Sets the reflected function instance (describing a function with generic types resolved) of a function declaration. */
  export function setReflectedFunction(node: ts.FunctionLikeDeclaration, instance: Function): void;
  /** Gets the reflected function template (describing a function with unresolved generic types) of a function declaration. */
  export function getReflectedFunctionTemplate(node: ts.FunctionLikeDeclaration): FunctionTemplate;
  /** Sets the reflected function template (describing a function with unresolved generic types) of a function declaration. */
  export function setReflectedFunctionTemplate(node: ts.FunctionLikeDeclaration, template: FunctionTemplate): void;
  /** Gets the reflected class instance (describing a class with generic types resolved) of a class declaration. */
  export function getReflectedClass(node: ts.ClassDeclaration): Class;
  /** Sets the reflected class instance (describing a class with generic types resolved) of a class declaration. */
  export function setReflectedClass(node: ts.ClassDeclaration, instance: Class): void;
  /** Gets the reflected class template (describing a class with unresolved generic types) of a class declaration. */
  export function getReflectedClassTemplate(node: ts.ClassDeclaration): ClassTemplate;
  /** Sets the reflected class template (describing a class with unresolved generic types) of a class declaration. */
  export function setReflectedClassTemplate(node: ts.ClassDeclaration, template: ClassTemplate): void;
  /** wabt.js, if available. */
  export import wabt = wabt;
  /** Options for {@link wasmToWast}. */
  export interface WasmToWastOptions {
      readDebugNames?: boolean;
      foldExprs?: boolean;
      inlineExport?: boolean;
      generateNames?: boolean;
  }
  /** Converts a WebAssembly binary to text format using linear syntax. Requires wabt.js to be present. */
  export function wasmToWast(buffer: Uint8Array, options?: WasmToWastOptions): string;
  /** Options for {@link wastToWasm}. */
  export interface WastToWasmOptions {
      filename?: string;
      canonicalizeLebs?: boolean;
      relocatable?: boolean;
      writeDebugNames?: boolean;
  }
  /** Converts WebAssembly text format using linear syntax to a binary. Requires wabt.js to be present. */
  export function wastToWasm(text: string, options?: WastToWasmOptions): Uint8Array;
  /** Tests if a string starts with the specified. */
  export function startsWith(str: string, sub: string): boolean;
  /** Writes an 8-bit integer value to a buffer at the specified offset. */
  export function writeByte(buffer: Uint8Array, offset: number, value: number): number;
  /** Writes a 1-bit integer value to a buffer at the specified offset. */
  export function writeBool(buffer: Uint8Array, offset: number, value: any): number;
  /** Writes a 16-bit integer value to a buffer at the specified offset. */
  export function writeShort(buffer: Uint8Array, offset: number, value: number): number;
  /** Writes a 32-bit integer value to a buffer at the specified offset. */
  export function writeInt(buffer: Uint8Array, offset: number, value: number): number;
  /** Writes a 64-bit integer value to a buffer at the specified offset. */
  export function writeLong(buffer: Uint8Array, offset: number, value: Long): number;
  /** Writes a 32-bit float value to a buffer at the specified offset. */
  export function writeFloat(buffer: Uint8Array, offset: number, value: number): number;
  /** Writes a 64-bit float value to a buffer at the specified offset. */
  export function writeDouble(buffer: Uint8Array, offset: number, value: number): number;
}

declare module 'assemblyscript/compiler' {
  import * as binaryen from "binaryen";
  import * as Long from "long";
  import Memory from "assemblyscript/memory";
  import Profiler from "assemblyscript/profiler";
  import { Type, TypeArgumentsMap, Class, ClassTemplate, ClassHandle, Function, FunctionTemplate, FunctionHandle, Variable, Enum, ReflectionObjectKind } from "assemblyscript/reflection";
  import * as ts from "assemblyscript/typescript";
  /** Library name prefix. */
  export const LIB_PREFIX = "lib:";
  /** Standard name prefix. */
  export const STD_PREFIX = "std:";
  /** Compiler options. */
  export interface CompilerOptions {
      /** Whether compilation shall be performed in silent mode without writing to console. Defaults to `false`. */
      silent?: boolean;
      /** Specifies the target architecture. Defaults to {@link CompilerTarget.WASM32}. */
      target?: CompilerTarget | "wasm32" | "wasm64";
      /** Whether to disable built-in tree-shaking. Defaults to `false`. */
      noTreeShaking?: boolean;
      /** Whether to disallow implicit type conversions. Defaults to `false`. */
      noImplicitConversion?: boolean;
      /** Whether to exclude the runtime. */
      noRuntime?: boolean;
      /** Runtime functions to export, defaults to 'malloc' and 'free'. */
      exportRuntime?: string[];
  }
  /** Compiler target. */
  export enum CompilerTarget {
      /** 32-bit WebAssembly target using uint pointers. */
      WASM32 = 0,
      /** 64-bit WebAssembly target using ulong pointers. */
      WASM64 = 1,
  }
  /**
    * The AssemblyScript compiler.
    *
    * Common usage is covered by the static methods {@link Compiler.compileFile} and {@link Compiler.compileString}
    * for convenience. Their diagnostics go to {@link Compiler.lastDiagnostics}.
    */
  export class Compiler {
      /** Diagnostic messages reported by the last invocation of {@link Compiler.compileFile} or {@link Compiler.compileString}. */
      static lastDiagnostics: ts.Diagnostic[];
      options: CompilerOptions;
      program: ts.Program;
      checker: ts.TypeChecker;
      entryFile: ts.SourceFile;
      libraryFile: ts.SourceFile;
      diagnostics: ts.DiagnosticCollection;
      module: binaryen.Module;
      signatures: {
          [key: string]: binaryen.Signature;
      };
      globalInitializers: binaryen.Expression[];
      target: CompilerTarget;
      profiler: Profiler;
      currentFunction: Function;
      runtimeExports: string[];
      usizeType: Type;
      functionTemplates: {
          [key: string]: FunctionTemplate;
      };
      classTemplates: {
          [key: string]: ClassTemplate;
      };
      globals: {
          [key: string]: Variable;
      };
      functions: {
          [key: string]: Function;
      };
      classes: {
          [key: string]: Class;
      };
      enums: {
          [key: string]: Enum;
      };
      startFunction: Function;
      startFunctionBody: ts.Statement[];
      pendingImplementations: {
          [key: string]: ClassTemplate;
      };
      memory: Memory;
      /**
        * Compiles an AssemblyScript file to WebAssembly.
        * @param filename Entry file name
        * @param options Compiler options
        * @returns Compiled module or `null` if compilation failed. In case of failure, diagnostics are stored in {@link Compiler#diagnostics}.
        */
      static compileFile(filename: string, options?: CompilerOptions): binaryen.Module | null;
      /**
        * Compiles an AssemblyScript string to WebAssembly.
        * @param source Source string
        * @param options Compiler options
        * @param fileName File to use for the entry file
        * @returns Compiled module or `null` if compilation failed. In case of failure, diagnostics are stored in {@link Compiler#diagnostics}.
        */
      static compileString(source: string, options?: CompilerOptions, fileName?: string): binaryen.Module | null;
      /**
        * Compiles a TypeScript program using AssemblyScript syntax to WebAssembly.
        * @param program TypeScript program
        * @param options Compiler options
        * @returns Compiled module or `null` if compilation failed. In case of failure, diagnostics are stored in {@link Compiler#diagnostics}.
        */
      static compileProgram(program: ts.Program, options?: CompilerOptions): binaryen.Module | null;
      /** Gets the configured byte size of a pointer. `4` when compiling for 32-bit WebAssembly, `8` when compiling for 64-bit WebAssembly. */
      readonly usizeSize: number;
      /** Gets the size of an array header in bytes. */
      readonly arrayHeaderSize: number;
      /**
        * Constructs a new AssemblyScript compiler.
        * @param program TypeScript program
        * @param options Compiler options
        */
      constructor(program: ts.Program, options?: CompilerOptions);
      /** Reports a diagnostic message (adds it to {@link Compiler#diagnostics}) and prints it. */
      report(node: ts.Node, message: ts.DiagnosticMessage, arg0?: string | number, arg1?: string | number, arg2?: string | number): void;
      /** Mangles a global name (of a function, a class, ...) for use with binaryen. */
      mangleGlobalName(name: string, sourceFile: ts.SourceFile): string;
      /** Scans over the sources and initializes the reflection structure. */
      initialize(): void;
      /** Gets an existing signature if it exists and otherwise creates it. */
      getOrAddSignature(argumentTypes: Type[], returnType: Type): binaryen.Signature;
      /** Initializes the statically linked or imported runtime. */
      initializeRuntime(): void;
      /** Initializes a global variable. */
      initializeGlobal(node: ts.VariableStatement): void;
      /** Adds a global variable. */
      addGlobal(name: string, type: Type, mutable: boolean, initializerNode?: ts.Expression): void;
      /** Initializes a top-level function. */
      initializeFunction(node: ts.FunctionDeclaration): FunctionHandle;
      /** Initializes a class. */
      initializeClass(node: ts.ClassDeclaration): ClassHandle;
      /** Initializes a static method. */
      initializeStaticMethod(node: ts.MethodDeclaration | ts.GetAccessorDeclaration | ts.SetAccessorDeclaration): FunctionHandle;
      /** Initializes an instance method. */
      initializeInstanceMethod(node: ts.MethodDeclaration | ts.GetAccessorDeclaration | ts.SetAccessorDeclaration | ts.ConstructorDeclaration, parent: Class): FunctionHandle;
      /** Initializes an enum. */
      initializeEnum(node: ts.EnumDeclaration): Enum;
      /** Compiles the module and its components. */
      compile(): void;
      /** Compiles the start function if either a user-provided start function is or global initializes are present. */
      maybeCompileStartFunction(): void;
      /** Compiles a malloc invocation using the specified byte size. */
      compileMallocInvocation(size: number, clearMemory?: boolean): binaryen.Expression;
      /** Compiles a function. */
      compileFunction(instance: Function): binaryen.Function | null;
      /** Compiles a class. */
      compileClass(instance: Class): void;
      /** Amends the current break context when entering a loop, switch or similar. */
      enterBreakContext(): string;
      /** Amends the current break context when leaving a loop, switch or similar. */
      leaveBreakContext(): void;
      /** Textual break label according to the current break context state. */
      readonly currentBreakLabel: string;
      /** Compiles a statement. */
      compileStatement(node: ts.Statement): binaryen.Statement | null;
      /** Compiles an expression. */
      compileExpression(node: ts.Expression, contextualType: Type, convertToType?: Type, convertExplicit?: boolean): binaryen.Expression;
      /** Wraps an expression with a conversion where necessary. */
      maybeConvertValue(node: ts.Expression, expr: binaryen.Expression, fromType: Type, toType: Type, explicit: boolean): binaryen.Expression;
      /** Resolves a TypeScript type alias to the root AssemblyScript type where applicable, by symbol. */
      maybeResolveAlias(symbol: ts.Symbol): ts.Symbol;
      /** Resolves a TypeScript type to a AssemblyScript type. */
      resolveType(type: ts.TypeNode, acceptVoid?: boolean, typeArgumentsMap?: TypeArgumentsMap): Type | null;
      /** Resolves an identifier or name to the corresponding reflection object. */
      resolveReference(node: ts.Identifier | ts.EntityName, filter?: ReflectionObjectKind): Object | null;
      /** Resolves a list of type arguments to a type arguments map. */
      resolveTypeArgumentsMap(typeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[], declaration: ts.FunctionLikeDeclaration | ts.ClassDeclaration, baseTypeArgumentsMap?: TypeArgumentsMap): TypeArgumentsMap;
      /** Computes the binaryen signature identifier of a reflected type. */
      identifierOf(type: Type): string;
      /** Obtains the signature of the specified reflected function. */
      signatureOf(instance: Function): binaryen.Signature;
      /** Computes the binaryen type of a reflected type. */
      typeOf(type: Type): binaryen.Type;
      /** Computes the binaryen opcode category (i32, i64, f32, f64) of a reflected type. */
      categoryOf(type: Type): binaryen.I32Operations | binaryen.I64Operations | binaryen.F32Operations | binaryen.F64Operations;
      /** Computes the constant value binaryen expression of the specified reflected type. */
      valueOf(type: Type, value: number | Long): binaryen.Expression;
      debugInfo(): string;
  }
  export default Compiler;
}

declare module 'assemblyscript/memory' {
  /**
    * Static memory utilizies.
    *
    * @module assemblyscript/memory
    */ /** */
  import * as Long from "long";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** A static memory segment. */
  export interface MemorySegment {
      /** Offset in static memory. */
      offset: Long;
      /** Contents. */
      buffer: Uint8Array;
  }
  /** A static memory. */
  export class Memory {
      /** Compiler reference. */
      compiler: Compiler;
      /** Base offset. */
      baseOffset: Long;
      /** Current offset. */
      currentOffset: Long;
      /** Static memory segments. */
      segments: MemorySegment[];
      /** Pool of reusable static strings. */
      stringPool: {
          [key: string]: MemorySegment;
      };
      /** Constructs a new static memory instance. */
      constructor(compiler: Compiler, baseOffset: number | Long);
      /** Aligns the current offset to 8 bytes. */
      align(): Long;
      /** Creates a static string. */
      createString(value: string, reuse?: boolean): MemorySegment;
      /** Creates a static array. */
      createArray(values: Array<number | Long | string | null>, type: Type): MemorySegment;
  }
  export default Memory;
}

declare module 'assemblyscript/profiler' {
  /** A simple profiler used to measure compilation times. */
  export class Profiler {
      /** Cached labels. */
      labels: {
          [key: string]: number;
      };
      /**
        * Starts measuring using the specified label.
        * @param label Label
        */
      start(label: string): void;
      /**
        * Ends measuring using the specified label.
        * @param label Label
        * @returns High resolution time span in milliseconds
        */
      end(label: string): number;
  }
  export default Profiler;
}

declare module 'assemblyscript/expressions/arrayliteral' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles an array literal expression. */
  export function compileArrayLiteral(compiler: Compiler, node: ts.ArrayLiteralExpression, contextualType: Type): Expression;
}

declare module 'assemblyscript/expressions/as' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles an 'as' expression explicitly converting from one type to another. */
  export function compileAs(compiler: Compiler, node: ts.AssertionExpression, contextualType: Type): Expression;
  export default compileAs;
}

declare module 'assemblyscript/expressions/binary' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a binary expression. Covers addition, multiplication and so on. */
  export function compileBinary(compiler: Compiler, node: ts.BinaryExpression, contextualType: Type): Expression;
  export default compileBinary;
  /** Compiles a binary assignment expression. */
  export function compileAssignment(compiler: Compiler, node: ts.BinaryExpression, contextualType: Type): Expression;
  /** Compiles a binary assignment expression with a pre-computed value. */
  export function compileAssignmentWithValue(compiler: Compiler, node: ts.BinaryExpression, value: Expression, contextualType: Type): Expression;
  /** Compiles a binary logical AND or OR expression. */
  export function compileLogicalAndOr(compiler: Compiler, node: ts.BinaryExpression): Expression;
  /** Compiles any expression so that it evaluates to a boolean result indicating whether it is true-ish. */
  export function compileIsTrueish(compiler: Compiler, node: ts.Expression): Expression;
}

declare module 'assemblyscript/expressions/call' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  /** Compiles a function call expression. */
  export function compileCall(compiler: Compiler, node: ts.CallExpression): Expression;
  export default compileCall;
}

declare module 'assemblyscript/expressions/conditional' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a conditional (ternary) expression. */
  export function compileConditional(compiler: Compiler, node: ts.ConditionalExpression, contextualType: Type): Expression;
  export default compileConditional;
}

declare module 'assemblyscript/expressions/elementaccess' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles an element access expression. Sets the element's value to `valueNode` if specified, otherwise gets it. */
  export function compileElementAccess(compiler: Compiler, node: ts.ElementAccessExpression, contextualType: Type, valueNode?: ts.Expression): Expression;
  export default compileElementAccess;
}

declare module 'assemblyscript/expressions/helpers/load' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Helper compiling a load operation. */
  export function compileLoad(compiler: Compiler, node: ts.Expression, type: Type, ptr: Expression, offset: number): Expression;
  export default compileLoad;
}

declare module 'assemblyscript/expressions/helpers/loadorstore' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Helper compiling a load operation if `valueToSet` has been omitted, otherwise a store operation. */
  export function compileLoadOrStore(compiler: Compiler, node: ts.Expression, type: Type, ptr: Expression, offset: number, valueToSet?: Expression, valueToSetContextualType?: Type): Expression;
  export default compileLoadOrStore;
}

declare module 'assemblyscript/expressions/helpers/store' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Helper compiling a store operation. */
  export function compileStore(compiler: Compiler, node: ts.Expression, type: Type, ptr: Expression, offset: number, value: Expression): Expression;
  export default compileStore;
}

declare module 'assemblyscript/expressions/identifier' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles an identifier expression. */
  export function compileIdentifier(compiler: Compiler, node: ts.Identifier, contextualType: Type): Expression;
  export default compileIdentifier;
}

declare module 'assemblyscript/expressions/literal' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a literal expression. */
  export function compileLiteral(compiler: Compiler, node: ts.LiteralExpression, contextualType: Type, negate?: boolean): Expression;
  export default compileLiteral;
}

declare module 'assemblyscript/expressions/new' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a 'new' expression. */
  export function compileNew(compiler: Compiler, node: ts.NewExpression, contextualType: Type): Expression;
  export default compileNew;
}

declare module 'assemblyscript/expressions/omitted' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles an omitted expression. */
  export function compileOmitted(compiler: Compiler, node: ts.OmittedExpression, contextualType: Type): Expression;
  export default compileOmitted;
}

declare module 'assemblyscript/expressions/parenthesized' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a parenthesized expression. */
  export function compileParenthesized(compiler: Compiler, node: ts.ParenthesizedExpression, contextualType: Type): Expression;
  export default compileParenthesized;
}

declare module 'assemblyscript/expressions/postfixunary' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a unary postfix expression. */
  export function compilePostfixUnary(compiler: Compiler, node: ts.PostfixUnaryExpression, contextualType: Type): Expression;
  export default compilePostfixUnary;
}

declare module 'assemblyscript/expressions/prefixunary' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a unary prefix expression. */
  export function compilePrefixUnary(compiler: Compiler, node: ts.PrefixUnaryExpression, contextualType: Type): Expression;
  export default compilePrefixUnary;
}

declare module 'assemblyscript/expressions/propertyaccess' {
  /** @module assemblyscript/expressions */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression } from "binaryen";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection";
  /** Compiles a property access expression. Sets the property's value to `valueNode` if specified, otherwise gets it. */
  export function compilePropertyAccess(compiler: Compiler, node: ts.PropertyAccessExpression, contextualType: Type, valueNode?: ts.Expression): Expression;
  export default compilePropertyAccess;
}

declare module 'assemblyscript/reflection/class' {
  /** @module assemblyscript/reflection */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Compiler } from "assemblyscript/compiler";
  import { FunctionTemplate, Function } from "assemblyscript/reflection/function";
  import { ReflectionObject, ReflectionObjectKind } from "assemblyscript/reflection/object";
  import { Property } from "assemblyscript/reflection/property";
  import { Type, TypeArgumentsMap } from "assemblyscript/reflection/type";
  /** Common base class of {@link Class} and {@link ClassTemplate}. */
  export abstract class ClassBase extends ReflectionObject {
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: ts.ClassDeclaration;
      constructor(kind: ReflectionObjectKind, compiler: Compiler, name: string, declaration: ts.ClassDeclaration);
      /** Tests if this class is generic. */
      readonly isGeneric: boolean;
      /** Tests if this class is exported. */
      readonly isExport: boolean;
      /** Tests if this class has been annotated with a decorator of the specified name. */
      hasDecorator(name: string): boolean;
      toString(): string;
  }
  /** Interface describing a reflected class method. */
  export interface ClassMethod {
      /** Class template with possibly unresolved type parameters. */
      template: FunctionTemplate;
      /** Class instance with type parameters resolved, if initialized yet. */
      instance?: Function;
  }
  /** Tests if the specified global name references a built-in array. */
  export function isBuiltinArray(globalName: string): boolean;
  /** Tests if the specified global name references a built-in string. */
  export function isBuiltinString(globalName: string): boolean;
  /** A class handle consisting of its instance, if any, and its template. */
  export interface ClassHandle {
      template: ClassTemplate;
      instance?: Class;
  }
  /** A class instance with generic parameters resolved. */
  export class Class extends ClassBase {
      /** Corresponding class template. */
      template: ClassTemplate;
      /** Reflected class type. */
      type: Type;
      /** Concrete type arguments. */
      typeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[];
      /** Type arguments map. */
      typeArgumentsMap: TypeArgumentsMap;
      /** Base class, if any. */
      base?: Class;
      /** Static and instance class properties. */
      properties: {
          [key: string]: Property;
      };
      /** Static and instance class methods. */
      methods: {
          [key: string]: ClassMethod;
      };
      /** Getter methods. */
      getters: {
          [key: string]: ClassMethod;
      };
      /** Setter methods. */
      setters: {
          [key: string]: ClassMethod;
      };
      /** Class constructor, if any. */
      ctor?: Function;
      /** Size in memory, in bytes. */
      size: number;
      /** Whether array access is supported on this class. */
      isArray: boolean;
      /** Whether this is a string-like class. */
      isString: boolean;
      /** Whether memory must be allocated implicitly. */
      implicitMalloc: boolean;
      /** Constructs a new reflected class and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, template: ClassTemplate, typeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[], base?: Class);
      /** Tests if this class extends another class. */
      extends(base: Class): boolean;
      /** Tests if this class is assignable to the specified (class) type. */
      isAssignableTo(type: Class): boolean;
  }
  export default Class;
  /** A class template with possibly unresolved generic parameters. */
  export class ClassTemplate extends ClassBase {
      /** Class instances by global name. */
      instances: {
          [key: string]: Class;
      };
      /** Base class template, if any. */
      base?: ClassTemplate;
      /** Base type arguments. */
      baseTypeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[];
      /** Static and instance class property declarations by simple name. */
      propertyDeclarations: {
          [key: string]: ts.PropertyDeclaration;
      };
      /** Static and instance method declarations by simple name. */
      methodDeclarations: {
          [key: string]: ts.MethodDeclaration;
      };
      /** Getter declarations by simple name. */
      getterDeclarations: {
          [key: string]: ts.MethodDeclaration;
      };
      /** Setter declarations by simple name. */
      setterDeclarations: {
          [key: string]: ts.MethodDeclaration;
      };
      /** Constructor declaration, if any. */
      ctorDeclaration?: ts.ConstructorDeclaration;
      /** Constructs a new reflected class template and binds it to its declaration. */
      constructor(compiler: Compiler, name: string, declaration: ts.ClassDeclaration, base?: ClassTemplate, baseTypeArguments?: ts.NodeArray<ts.TypeNode> | ts.TypeNode[]);
      /** Resolves this possibly generic class against the provided type arguments. */
      resolve(typeArgumentNodes: ts.NodeArray<ts.TypeNode> | ts.TypeNode[], typeArgumentsMap?: TypeArgumentsMap): Class;
  }
  /** Patches a declaration to inherit from its actual implementation. */
  export function patchClassImplementation(declTemplate: ClassTemplate, implTemplate: ClassTemplate): void;
}

declare module 'assemblyscript/reflection/enum' {
  /** @module assemblyscript/reflection */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Compiler } from "assemblyscript/compiler";
  import { ReflectionObject } from "assemblyscript/reflection/object";
  import { Property } from "assemblyscript/reflection/property";
  /** A reflected enum instance. */
  export class Enum extends ReflectionObject {
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: ts.EnumDeclaration;
      /** Enum values by simple name. */
      values: {
          [key: string]: Property;
      };
      /** Constructs a new reflected enum and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, declaration: ts.EnumDeclaration);
      toString(): string;
  }
  export default Enum;
}

declare module 'assemblyscript/reflection/function' {
  /** @module assemblyscript/reflection */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Expression, Type as BinaryenType, Function as BinaryenFunction, Signature } from "binaryen";
  import { Class } from "assemblyscript/reflection/class";
  import { Compiler } from "assemblyscript/compiler";
  import { ReflectionObject, ReflectionObjectKind } from "assemblyscript/reflection/object";
  import { Type, TypeArgumentsMap } from "assemblyscript/reflection/type";
  import { Variable } from "assemblyscript/reflection/variable";
  /** A function handle consisting of its instance, if any, and its template. */
  export interface FunctionHandle {
      template: FunctionTemplate;
      instance?: Function;
  }
  /** Common base class of {@link Function} and {@link FunctionTemplate}. */
  export abstract class FunctionBase extends ReflectionObject {
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: ts.FunctionLikeDeclaration;
      /** Class declaration reference, if any. */
      classDeclaration?: ts.ClassDeclaration;
      protected constructor(kind: ReflectionObjectKind, compiler: Compiler, name: string, declaration: ts.FunctionLikeDeclaration);
      /** Tests if this function is an import. */
      readonly isImport: boolean;
      /** Tests if this function is exported. */
      readonly isExport: boolean;
      /** Tests if this function is an instance member / not static. */
      readonly isInstance: boolean;
      /** Tests if this function is the constructor of a class. */
      readonly isConstructor: boolean;
      /** Tests if this function is a getter. */
      readonly isGetter: boolean;
      /** Tests if this function is a setter. */
      readonly isSetter: boolean;
      /** Tests if this function is generic. */
      readonly isGeneric: boolean;
      toString(): string;
  }
  /** Interface describing a reflected function parameter. */
  export interface FunctionParameter {
      /** Simple name. */
      name: string;
      /** Resolved type. */
      type: Type;
      /** Parameter node reference. */
      node: ts.Node;
      /** Whether this parameter also introduces a property (like when used with the `public` keyword). */
      isAlsoProperty?: boolean;
      /** Optional value initializer. */
      initializer?: ts.Expression;
  }
  /** A function instance with generic parameters resolved. */
  export class Function extends FunctionBase {
      /** Internal name for use with call operations. */
      internalName: string;
      /** Corresponding function template. */
      template: FunctionTemplate;
      /** Concrete type arguments. */
      typeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[];
      /** Resolved type arguments. */
      typeArgumentsMap: TypeArgumentsMap;
      /** Function parameters including `this`. */
      parameters: FunctionParameter[];
      /** Resolved return type. */
      returnType: Type;
      /** Parent class, if any. */
      parent?: Class;
      /** Body reference, if not just a declaration. */
      body?: ts.Block | ts.Expression;
      /** Current unique local id. */
      uniqueLocalId: 1;
      /** Local variables. */
      locals: Variable[];
      /** Local variables by name for lookups. */
      localsByName: {
          [key: string]: Variable;
      };
      /** Resolved binaryen parameter types. */
      binaryenParameterTypes: BinaryenType[];
      /** Resolved binaryen return type. */
      binaryenReturnType: BinaryenType;
      /** Binaryen signature id, for example "iiv". */
      binaryenSignatureId: string;
      /** Binaryen signature reference. */
      binaryenSignature: Signature;
      /** Whether this function has already been compiled. */
      compiled: boolean;
      /** Whether this function has been imported. */
      imported: boolean;
      /** Number of the current break context. */
      breakNumber: number;
      /** Depth within the current break context. */
      breakDepth: number;
      /** Binaryen function reference. */
      binaryenFunction: BinaryenFunction;
      /** Constructs a new reflected function instance and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, template: FunctionTemplate, typeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[], typeArgumentsMap: TypeArgumentsMap, parameters: FunctionParameter[], returnType: Type, parent?: Class, body?: ts.Block | ts.Expression);
      /** Gets the current break label for use with binaryen loops and blocks. */
      readonly breakLabel: string;
      /** Introduces an additional local variable of the specified name and type. */
      addLocal(name: string, type: Type, mutable?: boolean, value?: number | Long | null): Variable;
      /** Introduces an additional unique local variable of the specified type. */
      addUniqueLocal(type: Type, prefix?: string): Variable;
      /** Compiles a call to this function using the specified arguments. Arguments to instance functions include `this` as the first argument or can specifiy it in `thisArg`. */
      compileCall(argumentNodes: ts.NodeArray<ts.Expression> | ts.Expression[], thisArg?: Expression): Expression;
      /** Makes a call to this function using the specified operands. */
      call(operands: Expression[]): Expression;
  }
  export default Function;
  /** A function template with possibly unresolved generic parameters. */
  export class FunctionTemplate extends FunctionBase {
      /** Declaration reference. */
      declaration: ts.FunctionLikeDeclaration;
      /** So far resolved instances by global name. */
      instances: {
          [key: string]: Function;
      };
      /** Parent class, if any. */
      parent: Class | undefined;
      /** Constructs a new reflected function template and binds it to its TypeScript declaration. */
      constructor(compiler: Compiler, name: string, declaration: ts.FunctionLikeDeclaration, parent?: Class);
      /** Resolves this possibly generic function against the provided type arguments. */
      resolve(typeArguments: ts.NodeArray<ts.TypeNode> | ts.TypeNode[], typeArgumentsMap?: TypeArgumentsMap): Function;
  }
}

declare module 'assemblyscript/reflection/object' {
  /** @module assemblyscript/reflection */ /** */
  import { Compiler } from "assemblyscript/compiler";
  /** Object kinds. Also used as filters. */
  export const enum ReflectionObjectKind {
      Variable = 1,
      Enum = 2,
      FunctionTemplate = 4,
      Function = 8,
      ClassTemplate = 16,
      Class = 32,
      Property = 64,
  }
  /** Base class of all reflection objects. */
  export abstract class ReflectionObject {
      /** Object kind. */
      kind: ReflectionObjectKind;
      /** Compiler reference. */
      compiler: Compiler;
      /** Constructs a neww reflection object. */
      constructor(kind: ReflectionObjectKind, compiler: Compiler);
  }
  export default ReflectionObject;
}

declare module 'assemblyscript/reflection/property' {
  /** @module assemblyscript/reflection */ /** */
  import * as ts from "assemblyscript/typescript";
  import { Compiler } from "assemblyscript/compiler";
  import { Type } from "assemblyscript/reflection/type";
  import { ReflectionObject } from "assemblyscript/reflection/object";
  /** A reflected property. Also used to describe enum values. */
  export class Property extends ReflectionObject {
      /** Global name. */
      name: string;
      /** Simple name. */
      simpleName: string;
      /** Declaration reference. */
      declaration: ts.PropertyDeclaration | ts.EnumMember;
      /** Resolved type. */
      type: Type;
      /** Offset in memory, if applicable. */
      offset: number;
      /** Initializer expression, if applicable. */
      initializer: ts.Expression | undefined;
      /** Constructs a new reflected property. */
      constructor(compiler: Compiler, name: string, declaration: ts.PropertyDeclaration | ts.EnumMember, type: Type, offset: number, initializer?: ts.Expression);
      /** Tests if this property is an instance member. */
      readonly isInstance: boolean;
      toString(): string;
  }
  export default Property;
}

declare module 'assemblyscript/reflection/type' {
  /** @module assemblyscript/reflection */ /** */
  import * as ts from "assemblyscript/typescript";
  import Class from "assemblyscript/reflection/class";
  /** Core type kinds including range aliases. */
  export enum TypeKind {
      /** First integer of any size and signage. */
      FirstInteger = 0,
      /** First unsigned integer of any size. */
      FirstUnsigned = 0,
      /** Unsigned 8-bit integer type. */
      u8 = 0,
      /** Unsigned 16-bit integer type. */
      u16 = 1,
      /** Unsigned 32-bit integer type. */
      u32 = 2,
      /** Unsigned 64-bit integer type. */
      u64 = 3,
      /** Last unsigned integer of any size. */
      LastUnsigned = 4,
      /** Unsigned 32-/64-bit pointer type. */
      usize = 4,
      /** First signed integer of any size. */
      FirstSigned = 5,
      /** Signed 8-bit integer type. */
      i8 = 5,
      /** Signed 16-bit integer type. */
      i16 = 6,
      /** Signed 32-bit integer type. */
      i32 = 7,
      /** Last signed integer of any size. */
      LastSigned = 8,
      /** Last integer of any size and signage. */
      LastInteger = 8,
      /** Signed 64-bit integer type. */
      i64 = 8,
      /** First float of any size. */
      FirstFloat = 9,
      /** 32-bit float type. */
      f32 = 9,
      /** Last float of any size. */
      LastFloat = 10,
      /** 64-bit float type. */
      f64 = 10,
      /** Bool type. */
      bool = 11,
      /** Void type. */
      void = 12,
  }
  /** A reflected type. */
  export class Type {
      /** Type kind. */
      kind: TypeKind;
      /** Size in linear memory. */
      size: number;
      /** The underlying class, if a pointer. */
      underlyingClass?: Class;
      /** The respective nullable type of this type, if applicable. */
      nullableType?: Type;
      /** The respective non-nullable type of this type, if applicable. */
      nonNullableType?: Type;
      /** Constructs a new reflected type. Not meant to introduce any types other than the core types. */
      constructor(kind: TypeKind, size: number, underlyingClass?: Class);
      /** Tests if this is an integer type of any size. */
      readonly isAnyInteger: boolean;
      /** Tests if this is a float type of any size. */
      readonly isAnyFloat: boolean;
      /** Tests if this is a numeric type of any size. */
      readonly isNumeric: boolean;
      /** Tests if this is a signed integer type of any size. */
      readonly isSigned: boolean;
      /** Tests if this is an 8-bit integer type of any signage. */
      readonly isByte: boolean;
      /** Tests if this is a 16-bit integer type of any signage. */
      readonly isShort: boolean;
      /** Tests if this is a 32-bit integer type of any signage. */
      readonly isInt: boolean;
      /** Tests if this is a 64-bit integer type of any signage. */
      readonly isLong: boolean;
      /** Tests if this is a pointer with an underlying class. */
      readonly isClass: boolean;
      /** Tests if this is a pointer with an underlying array-like class. */
      readonly isArray: boolean;
      /** Tests if this is a pointer with an underlying string-like class. */
      readonly isString: boolean;
      /** Tests if this is a nullable type. */
      readonly isNullable: boolean;
      /** Gets the common name of a temporary variable of this type. */
      readonly tempName: string;
      /** Amends a pointer to reference the specified underlying class. */
      withUnderlyingClass(underlyingClass: Class): Type;
      /** Derives the respective nullable type of this type. */
      asNullable(): Type;
      toString(): string;
      /** Reflected bool type. */
      static bool: Type;
      /** Reflected signed 8-bit integer type. */
      static i8: Type;
      /** Reflected unsigned 8-bit integer type. */
      static u8: Type;
      /** Reflected signed 16-bit integer type. */
      static i16: Type;
      /** Reflected unsigned 16-bit integer type. */
      static u16: Type;
      /** Reflected signed 32-bit integer type. */
      static i32: Type;
      /** Reflected unsigned 32-bit integer type. */
      static u32: Type;
      /** Reflected signed 64-bit integer type. */
      static i64: Type;
      /** Reflected unsigned 64-bit integer type. */
      static u64: Type;
      /** Reflected 32-bit float type. */
      static f32: Type;
      /** Reflected 64-bit float type. */
      static f64: Type;
      /** Reflected 32-bit pointer type. Relevant only when compiling for 32-bit WebAssembly. */
      static usize32: Type;
      /** Reflected 64-bit pointer type. Relevant only when compiling for 64-bit WebAssembly. */
      static usize64: Type;
      /** Reflected void type. */
      static void: Type;
  }
  export default Type;
  /** Interface describing a reflected type argument. */
  export interface TypeArgument {
      /** Reflected type. */
      type: Type;
      /** TypeScript type node. */
      node: ts.TypeNode;
  }
  /** Interface describing a reflected type arguments map. */
  export interface TypeArgumentsMap {
      [key: string]: TypeArgument;
  }
}

declare module 'assemblyscript/reflection/variable' {
  /** @module assemblyscript/reflection */ /** */
  import { Compiler } from "assemblyscript/compiler";
  import { ReflectionObject } from "assemblyscript/reflection/object";
  import { Type } from "assemblyscript/reflection/type";
  /** A reflected variable. */
  export class Variable extends ReflectionObject {
      /** Simple or global name, depending on context. */
      name: string;
      /** Reflected type. */
      type: Type;
      /** Whether mutable or not. */
      mutable: boolean;
      /** Local index, if applicable. */
      localIndex: number;
      /** Constant value, if applicable. */
      constantValue: number | Long | null;
      /** Constructs a new reflected variable. */
      constructor(compiler: Compiler, name: string, type: Type, mutable?: boolean, localIndex?: number, constantValue?: number | Long | null);
      /** Tests if this variable is declared constant. */
      readonly isConstant: boolean;
      /** Tests if this is a global variable. */
      readonly isGlobal: boolean;
      /** Tests if this is a local variable. */
      readonly isLocal: boolean;
      /** Tests if this variable's value is inlined. */
      readonly isInlined: boolean;
      toString(): string;
  }
  export default Variable;
}

declare module 'assemblyscript/typescript/diagnosticMessages.generated' {
  /** @module assemblyscript/typescript */ /** */
  import { DiagnosticCategory } from "assemblyscript/typescript";
  /** AssemblyScript specific diagnostic messages. */
  export const DiagnosticsEx: {
      Unsupported_node_kind_0_in_1: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unsupported_modifier_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unsupported_literal_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Type_expected: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unresolvable_type_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unresolvable_identifier_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Start_function_has_already_been_defined: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Start_function_already_defined_here: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Conversion_from_0_to_1_requires_an_explicit_cast: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Conversion_from_0_to_1_will_fail_when_switching_between_WASM32_64: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Type_0_is_invalid_in_this_context: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Identifier_0_is_invalid_in_this_context: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Assuming_0_instead_of_1: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Assuming_return_type_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Assuming_variable_type_0: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Types_0_and_1_are_incompatible: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Literal_overflow_Compiling_to_a_value_in_range_0_to_1_instead: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Optional_parameters_must_specify_an_initializer: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Unconditional_endless_loop_detected: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Function_with_a_return_type_must_return_a_value: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Function_without_a_return_type_cannot_return_a_value: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
      Compiling_global_with_unsupported_constant_initializer_expression_as_mutable: {
          code: number;
          category: DiagnosticCategory;
          key: string;
          message: string;
      };
  };
  export default DiagnosticsEx;
}

